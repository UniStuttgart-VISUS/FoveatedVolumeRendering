% % Fazit der Arbeit
\chapter{Fazit}\label{chap:zusfas}
% \todo{Fazit wertend (was hat gut und schlecht funktioniert aber auf den gesamten Zeitverlauf der Arbeit bezogen).}
Die Einarbeitung in das Projekt war relativ aufwendig und es hat daher eine gewisse Zeit gebraucht, bis sich ein Überblick über die Struktur des Projektes gebildet werden konnte.
Dies ist im Hinblick auf ein umfangreiches Projekt nicht verwunderlich, wurde aber auch dadurch erschwert, dass unter Anderem mit verschiedenen ungewohnten Programmiersprachen, Programmierumgebungen und Programmierbibliotheken sich auseinander gesetzt werden musste.
Die Auseinandersetzung mit diesen hat aber viele neue Einblicke in unterschiedliche Bereiche ermöglicht, die sich im Laufe dieser Arbeit sich als sehr hilfreich repräsentiert haben und als Grundlage für neue Arbeiten dienen werden.
So haben sich vor allem Einblicke in die GPU Architektur als sehr interessant und hilfreich bei der Implementierung der Implementierung der Raycasts, besonders des DDC Raycasts erwiesen.
Zum Beispiel wurde aufgrund der Einblicke in die Grundlagen der GPU Architektur im Laufe dieser Arbeit die Implementierung des DDC Raycasts strukturell verändert, wodurch sich die Performanz weiter verbesserte.
Trotzdem, wie in der Diskussion (Abschnitt \ref{sec::disc}) sich schon herausgestellt hat, muss man bei der Programmierung für die GPU auf bestimmte Aspekte achten und meistens ist eine Optimierung immer noch möglich.
Die Auseinandersetzung mit den Grundlagen und Limitierungen des Sehapparates (Abschnitt \ref{sec::eye}) war für das Verständnis des Hauptziels dieser Arbeit und für die Umsetzung der Implementierungen wichtig und hat die Art und Weise, wie die Implementierungen entworfen wurden, beeinflusst.
Allerdings wurden die Parameter, wie die unterschiedlichen Auflösungen und die unterschiedlichen Ausmaße der Bereiche in den verschiedenen Raycast Methoden, nach der eigenen Wahrnehmung eingestellt.
Diese Parameter könnten für weitere Arbeiten genauer untersucht werden, um die optimalen Werte zu finden.
Zum Beispiel die könnte untersucht werden, wie es sich auswirkt, wenn die Größe der inneren Ellipse des DDC Raycasts auf die genaue Größe der Fovea auf dem Bildschirm angepasst wird und wie es wahrgenommen wird, wenn die innere Ellipse stattdessen kleiner oder größer dargestellt wird.

Im Verlauf der Arbeit wurde klar, dass die Umsetzung des Volumenrenderings durch einen Raycast sehr gut möglich ist und auch viele Erweiterungen und Modifikationen des Volumenrenderings, wie das Anwenden einer Tranferfunktion oder auch insbesondere wahrnehmungsorientierte Methoden, zum Beispiel das Reduzierung der Strahlabtastrate im peripheren Bereich, dadurch einfach umgesetzt werden können.
Wahrnehmungsorientiertes Rendering ist aber nicht auf das Volumenrendering und Raycasts beschränkt.
Die Referenzliteratur in Abschnitt \ref{ss::pfwov} zeigte diesbezüglich Arbeiten, die wahrnehmungsorientierte Methoden in Anwendungen anwenden, die eine Grafikpipeline zur Berechnung verwenden.
Die vorgestellten Methoden MDC und DDC können an sich auch in Anwendungen, die eine Grafikpipeline verwenden, umgesetzt werden.

Die Anfertigung von Arbeitspaketen hat die Strukturierung der Arbeit erleichtert und erwies sich auch für die Implementierungen der Arbeit als hilfreich, da diese unter Anderem gewisse Vorgaben repräsentierten und eine ungefähre Einschätzung des Zeitaufwandes ermöglichten.

Die Arbeit hat gezeigt, dass wahrnehmungsorientierte Methoden durchaus einen Performanzgewinn erbringen können ohne die Bildqualität wahrnehmbar zu beeinträchtigen.
Alleine die Verwendung einer varrierten Strahlabtastrate für den Standard Raycast hat selbst bei genauer Betrachtung eines statischen Bildes einer Berechnung kaum wahrnehmbare Veränderungen der Bildqualität nach sich gezogen und trotzdem die Ausführungszeit spürbar verbessert.
Die Anpassungen der Bildabtastrate wurde jeweils durch die Raycast Methoden MDC und DDC umgesetzt und hat jeweils einen noch größeren Performanzgewinn ermöglicht.
Dabei hat sich die Implementierung des MDC Raycasts als vergleichsweise einfach erwiesen und war mit wenigen Änderungen zu dem ursprünglichen Raycast-Verhaltens implementierbar.
Erstaunlicherweise lieferte der MDC Raycast im späteren Vergleich mit dem DDC Raycast sowohl eine bessere Bildqualität, als auch eine bessere Performanz, wodurch dieser durch eine schnelle Ausführung mit wenig Varianz für die Verwendung eines Eyetrackers gut geeignet war.
Trotzdem gibt es weitere Möglichkeiten diesen zu verbessern. 
Zum Beispiel kann die Bildabtastrate im äußeren Bereich weiter verringert werden oder auch noch ein dritter Bereich eingefügt werden, solange der Overhead dadurch nicht die Berechnung eines Bildes zu sehr beeinträchtigt.
Der DDC Raycast war deutlich zeitaufwendiger zu implementieren.
Die Indizes mussten vergleichsweise aufwändig auf Bildkoordinaten abgebildet werden und anschließend war es noch notwendig, diese zu interpolieren.
Dafür erreichte der DDC Raycast bessere Spitzenwerte, ist aber von der Gesamtperformanz her aufgrund des Overheads und der deutlich größeren Varianz der Ausführungszeiten schlechter als der MDC Raycast.
Auch die Bildqualität ist im äußeren Bereich deutlich geringer.
Dies wird aber aufgrund der Limitationen des visuellen Wahrnehmungssystems bei der Verwendung eines Eyetrackers lange nicht so wahrgenommen, wie wenn man nur das statische Bild ohne einen Eyetracker betrachtet.
Auch der DDC Raycast ist wie im Diskussionsabschnitt (Abschnitt \ref{sec::disc}) schon erwähnt wurde, ausbaufähig und kann vermutlich bei einer besseren Umsetzung deutlich effizienter werden.
Im Vergleich zur Referenzliteratur, in welcher höhere Faktoren in der Performanzgewinnung durch die Implementation von wahrnehmungsorientierten Verfahren erzielt wurden, liegt dies hier unter anderem auch daran, dass die Raycast Methoden, vor allem der DDC Raycast, in der Implementierung möglichst variabel gehalten wurde.
Eine Festlegung auf bestimmte Parameter würde es ermöglichen, die Implementierung des DDC Raycasts anders und effizienter umzusetzen.

Wie in Abschnitt \ref{}Ein interessanter Ansatz für die Zukunft, wäre eine implementierung die wie eine Art Linse (verweis überlegung im arbeitspaket), die die Strahldichte gleichmäßig reduzieren kann
% Bezogen Auf die Arbeit mit dem Eyetracker war es sehr interessant damit zu arbeiten.
% Dass die api eine validierung der augendaten zur verfügung stellt hat sehr geholfen. Insgesamt ist aber bei der Arbeit mit dem Eyetracker noch aufgefallen, dass es entweder durch die Tremor-Bewegungen des Auges oder durch Messungenauigkeiten des Eyetrackers zu einem Flackern kommt. Da das Bild auf das Flackern reagiert ziehen sich veränderte Eigenschaften die Aufmerksamkeit auf sich und dadurch wirkt das Bild ein wenig störend. Für eine weitere Arbeit mit Eyetracking Daten sollten diese gefiltert oder geglättet werden.
% Bezogen auf die Erstellung und Darstellung der Messwerte kann man sagen, dass dies doch noch ein erheblicher Aufwand war, die Messungen in dem Projekt umzusetzen und aus den Messdaten grafische repräsentationen zu bilden, die verständlich sind.
% Schlussendlich konnten die Messmethoden so implementiert werden, dass diese reproduzierbar sind.
% Für die Messung war es auch sinnvoll, verschiedene Mauspositionen bei der Darstellung eines Volumens zu betrachten.
% Die Darstellung durch Heatmaps veranschaulicht die vor- und nachteile der methoden ddc und mdc bei der betrachtung eines volumens und die darstellung der boxplots ermöglichte einen noch genaueren und verständlicheren vergleich.
% Abschließend ist zu sagen, dass sowohl die vorgestellten Methoden als auch wahrnehmungs-orientiertes Rendering hohes Potential hat und aufgrund der größeren Bildschirme und Pixeldichten vor allem auch in VR-Anwendungen, die nicht immer mit high-end hardware ausgestattet sind, dies auch in zukunft einen wichtigen aspekt haben wird.
% Ausserdem ist die Performanz nicht der einzige Grund für wahrnehmungsorientiertes Rendering. Wie auch in der Referenzliteratur beschrieben, kann dieses auch für Informativere Darstellungen sorgen. Oder auch die Augenbewegungen für die Steuerung von Anwendungen verwenden.